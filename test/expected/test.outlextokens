[inlinecmt, // All valid, 1] 
[function, function, 2] [id, add, 2] [openpar, (, 2] [id, num1, 2] [colon, :, 2] [integer, integer, 2] [comma, ,, 2] [id, num2, 2] [colon, :, 2] [integer, integer, 2] [closepar, ), 2] [returntype, =>, 2] [integer, integer, 2] [opencubr, {, 2] 
[return, return, 3] [openpar, (, 3] [id, num1, 3] [plus, +, 3] [id, num2, 3] [closepar, ), 3] [semi, ;, 3] 
[closecubr, }, 4] 
[blockcmt, /* Invalid ID, but the lexer should recover and manage to parse the rest OK */, 6] 
[invalidchar, _, 7] [id, bad_id, 7] [assign, =, 7] [intnum, 123, 7] [div, /, 7] [floatnum, 1.23e+45, 7] [semi, ;, 7] 
[inlinecmt, // Valid ID, but the int is invalid, 9] 
[id, good_id, 10] [assign, =, 10] [invalidnum, 0123, 10] [eq, ==, 10] [id, my_var, 10] [semi, ;, 10] 
[inlinecmt, // Invalid chars thrown in, 12] 
[id, my_, 13] [invalidchar, #, 13] [id, var, 13] [assign, =, 13] [id, resu, 13] [invalidchar, &, 13] [id, t, 13] [plus, +, 13] [intnum, 34, 13] [id, fe, 13] [semi, ;, 13] 
[inlinecmt, // Should parse as [::, ::, :] if it's properly looking forwards, 15] 
[scopeop, ::, 16] [scopeop, ::, 16] [colon, :, 16] 
[inlinecmt, // Should parse as [<>, =], not [<, >=], 18] 
[noteq, <>, 19] [assign, =, 19] 
[inlinecmt, // Should parse as [<=, >], 21] 
[leq, <=, 22] [gt, >, 22] 
[inlinecmt, // Should parse as [<, 123] if it backtracks correctly, 24] 
[lt, <, 25] [intnum, 123, 25] 
[inlinecmt, // The language is case-sensitive, these should be IDs, 27] 
[id, INTEGER, 28] [id, integeR, 28] [id, IF, 28] [id, localVar, 28] 
[inlinecmt, // Valid leading/trailing zeros, 30] 
[intnum, 1000, 31] 
[floatnum, 12.0, 32] 
[floatnum, 12.000056, 33] 
[invalidnum, 34.110e10, 34] 
[inlinecmt, // Invalid leading/trailing zeros, even if there's multiple, 36] 
[invalidnum, 01, 37] 
[invalidnum, 0000000000000001, 38] 
[invalidnum, 12.3450, 39] 
[invalidnum, 12.1234000, 40] 
[invalidnum, 123.0e-01, 41] 
[invalidnum, 123.0e+0000001, 42] 
[invalidnum, 123.00e-1, 43] 
[inlinecmt, // Block comment between two other valid tokens, 45] 
[localvar, localvar, 46] [id, my_var, 46] [colon, :, 46] [integer, integer, 46] [blockcmt, /* TODO: fix this */, 46] [assign, =, 46] [intnum, 123, 46] 
[invalidcmt, /* Layer 1\n  /* Layer 2\n  */ Close layer 2, but not layer 1\n\nThis is considered part of the multi-line comment above because we didn't match every /* with a */\n, 48]